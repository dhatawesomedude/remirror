## API Report File for "jest-remirror"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionsFromExtensions } from '@remirror/core';
import { AnyExtension } from '@remirror/core';
import { Attrs } from '@remirror/core';
import { AttrsParams } from '@remirror/core';
import { CommandFunction } from '@remirror/core';
import { DocExtension } from '@remirror/core';
import { EditorSchema } from '@remirror/core';
import { EditorState } from '@remirror/core';
import { EditorStateParams } from '@remirror/core';
import { EditorViewParams } from '@remirror/core';
import { Extension } from '@remirror/core';
import { FireParams } from 'jest-prosemirror';
import { HelpersFromExtensions } from '@remirror/core';
import { InjectedRemirrorProps } from '@remirror/react';
import { Mark } from 'prosemirror-model';
import { MarkExtension } from '@remirror/core';
import { Node } from 'prosemirror-model';
import { NodeExtension } from '@remirror/core';
import { ParagraphExtension } from '@remirror/core-extensions';
import { ProsemirrorNode } from '@remirror/core';
import { RemirrorProps } from '@remirror/react';
import { RenderResult } from '@testing-library/react/pure';
import { SchemaFromExtensions } from '@remirror/core';
import { SchemaParams } from '@remirror/core';
import { Slice } from 'prosemirror-model';
import { TestEditorViewParams } from 'jest-prosemirror';
import { TextExtension } from '@remirror/core';

// @public (undocumented)
export type AddContent<GExtension extends AnyExtension> = (content: TaggedProsemirrorNode<SchemaFromExtensions<GExtension>>) => AddContentReturn<GExtension>;

// @public (undocumented)
export interface AddContentReturn<GExtension extends AnyExtension> extends EditorStateParams<SchemaFromExtensions<GExtension>>, EditorViewParams<SchemaFromExtensions<GExtension>> {
    actions: ActionsFromExtensions<GExtension>;
    actionsCallback(callback: (actions: ActionsFromExtensions<GExtension>) => void): AddContentReturn<GExtension>;
    callback(fn: (content: Pick<AddContentReturn<GExtension>, 'helpers' | 'actions' | 'end' | 'state' | 'tags' | 'start' | 'doc' | 'view'>) => void): AddContentReturn<GExtension>;
    dispatchCommand(command: CommandFunction): AddContentReturn<GExtension>;
    doc: ProsemirrorNode;
    end: number;
    fire(params: FireParams): AddContentReturn<GExtension>;
    helpers: HelpersFromExtensions<GExtension>;
    helpersCallback(callback: (helpers: HelpersFromExtensions<GExtension>) => void): AddContentReturn<GExtension>;
    insertText(text: string): AddContentReturn<GExtension>;
    jumpTo(pos: 'start' | 'end'): AddContentReturn<GExtension>;
    // (undocumented)
    jumpTo(start: number, end?: number): AddContentReturn<GExtension>;
    overwrite: AddContent<GExtension>;
    paste(content: TaggedProsemirrorNode | string): AddContentReturn<GExtension>;
    press(key: string): AddContentReturn<GExtension>;
    replace(...content: string[] | TaggedProsemirrorNode[]): AddContentReturn<GExtension>;
    shortcut(shortcut: string): AddContentReturn<GExtension>;
    start: number;
    tags: Tags;
}

// @public
export type BaseExtensionNodeNames = Exclude<BaseExtensionNodes['name'], 'text'> | 'p';

// @public
export type BaseExtensionNodes = typeof nodeExtensions[number];

// @public (undocumented)
export interface BaseFactoryParams<GSchema extends EditorSchema = EditorSchema> extends Partial<AttrsParams> {
    name: string;
    schema: GSchema;
}

// Warning: (ae-forgotten-export) The symbol "CleanParams" needs to be exported by the entry point index.d.ts
//
// @public
export const clean: ({ schema, content }: CleanParams) => Node<EditorSchema<string, string>> | Node<any>[] | undefined;

// Warning: (ae-forgotten-export) The symbol "CoerceParams" needs to be exported by the entry point index.d.ts
//
// @public
export const coerce: ({ content, schema }: CoerceParams) => {
    nodes: TaggedProsemirrorNode<EditorSchema<string, string>>[];
    tags: Tags;
};

// @public (undocumented)
export interface CreateTestEditorExtensions<GPlainMarks extends Array<MarkExtension<any>>, GPlainNodes extends Array<NodeExtension<any>>, GAttrMarks extends Array<MarkExtension<any>>, GAttrNodes extends Array<NodeExtension<any>>, GOthers extends Array<Extension<any>>> {
    attrMarks: GAttrMarks;
    attrNodes: GAttrNodes;
    others: GOthers;
    plainMarks: GPlainMarks;
    plainNodes: GPlainNodes;
}

// @public (undocumented)
export type CreateTestEditorReturn<GPlainMarks extends Array<MarkExtension<any>>, GPlainNodes extends Array<NodeExtension<any>>, GAttrMarks extends Array<MarkExtension<any>>, GAttrNodes extends Array<NodeExtension<any>>, GOthers extends Array<Extension<any>>, GExtension extends GenericExtension<GPlainMarks, GPlainNodes, GAttrMarks, GAttrNodes, GOthers> = GenericExtension<GPlainMarks, GPlainNodes, GAttrMarks, GAttrNodes, GOthers>> = Omit<InjectedRemirrorProps<GExtension>, 'view'> & TestEditorViewParams<SchemaFromExtensions<GExtension>> & {
    utils: RenderResult;
    add: AddContent<GExtension>;
    nodes: NodeWithoutAttrs<GetNames<GPlainNodes> | BaseExtensionNodeNames>;
    marks: MarkWithoutAttrs<GetNames<GPlainMarks>>;
    attrNodes: NodeWithAttrs<GetNames<GAttrNodes>>;
    attrMarks: MarkWithAttrs<GetNames<GAttrMarks>>;
    getState(): EditorState<SchemaFromExtensions<GExtension>>;
    schema: SchemaFromExtensions<GExtension>;
    p: (...content: TaggedContentWithText[]) => TaggedProsemirrorNode;
    doc: (...content: TaggedContentWithText[]) => TaggedProsemirrorNode;
};

// @public
export const fragment: (...content: TaggedContentWithText[]) => TaggedContentWithText[];

// @public (undocumented)
export type GenericExtension<GPlainMarks extends Array<MarkExtension<any>>, GPlainNodes extends Array<NodeExtension<any>>, GAttrMarks extends Array<MarkExtension<any>>, GAttrNodes extends Array<NodeExtension<any>>, GOthers extends Array<Extension<any>>> = BaseExtensionNodes | GPlainMarks[number] | GPlainNodes[number] | GAttrMarks[number] | GAttrNodes[number] | GOthers[number];

// @public (undocumented)
export type GetNames<GExtensions extends AnyExtension[]> = GExtensions[number]['name'];

// @public
export const ignoreJSDOMWarnings: (val?: boolean) => void;

// @public
export const isTaggedNode: (val: unknown) => val is TaggedProsemirrorNode<import("@remirror/core").EditorSchema<string, string>>;

// @public
export const jsdomExtras: () => void;

// @public
export const jsdomPolyfill: () => void;

// Warning: (ae-forgotten-export) The symbol "MarkFactoryParams" needs to be exported by the entry point index.d.ts
//
// @public
export const markFactory: ({ name, schema, attrs, allowDupes }: MarkFactoryParams) => (...content: TaggedContentWithText[]) => TaggedProsemirrorNode<EditorSchema<string, string>>[];

// @public (undocumented)
export type MarkWithAttrs<GNames extends string> = {
    [P in GNames]: (attrs?: Attrs) => (...content: TaggedContentWithText[]) => TaggedProsemirrorNode[];
};

// @public (undocumented)
export type MarkWithoutAttrs<GNames extends string> = {
    [P in GNames]: (...content: TaggedContentWithText[]) => TaggedProsemirrorNode[];
};

// @public
export const nodeExtensions: (DocExtension | TextExtension | ParagraphExtension)[];

// Warning: (ae-forgotten-export) The symbol "NodeFactoryParams" needs to be exported by the entry point index.d.ts
//
// @public
export const nodeFactory: <GSchema extends EditorSchema<string, string> = EditorSchema<string, string>>({ name, schema, attrs, marks, }: NodeFactoryParams<GSchema>) => (...content: TaggedContentWithText[]) => TaggedProsemirrorNode<EditorSchema<string, string>>;

// @public (undocumented)
export type NodeWithAttrs<GNames extends string> = {
    [P in GNames]: (attrs?: Attrs) => (...content: TaggedContentWithText[]) => TaggedProsemirrorNode;
};

// @public (undocumented)
export type NodeWithoutAttrs<GNames extends string> = {
    [P in GNames]: (...content: TaggedContentWithText[]) => TaggedProsemirrorNode;
};

// @public
export const offsetTags: (tags: Tags, offset: number) => Tags;

// @public (undocumented)
export const remirrorMatchers: jest.ExpectExtendMap;

// @public
export const renderEditor: <GPlainMarks extends MarkExtension<any>[], GPlainNodes extends NodeExtension<any>[], GAttrMarks extends MarkExtension<any>[], GAttrNodes extends NodeExtension<any>[], GOthers extends Extension<any, never>[], GReturn extends CreateTestEditorReturn<GPlainMarks, GPlainNodes, GAttrMarks, GAttrNodes, GOthers, GenericExtension<GPlainMarks, GPlainNodes, GAttrMarks, GAttrNodes, GOthers>>, GExtension extends GenericExtension<GPlainMarks, GPlainNodes, GAttrMarks, GAttrNodes, GOthers>, GPlainMarkNames extends GPlainMarks[number]["name"], GAttrMarkNames extends GAttrMarks[number]["name"], GAttrNodeNames extends GAttrNodes[number]["name"], GPlainNodeNames extends "p" | "doc" | "paragraph" | GPlainNodes[number]["name"]>({ plainMarks, plainNodes, attrMarks, attrNodes, others, }?: Partial<CreateTestEditorExtensions<GPlainMarks, GPlainNodes, GAttrMarks, GAttrNodes, GOthers>>, props?: Partial<Pick<RemirrorProps<GExtension>, "label" | "children" | "onChange" | "attributes" | "styles" | "stringHandler" | "value" | "initialContent" | "onStateChange" | "editable" | "autoFocus" | "onFocus" | "onBlur" | "onFirstRender" | "onDispatchTransaction" | "usesBuiltInExtensions" | "usesDefaultStyles" | "editorStyles" | "css" | "insertPosition" | "forceEnvironment" | "suppressHydrationWarning" | "fallbackContent">>) => GReturn;

// @public
export const renderSSREditor: <GExtension extends AnyExtension = any>(extensions?: GExtension[], props?: Partial<Pick<RemirrorProps<GExtension>, "label" | "children" | "onChange" | "attributes" | "styles" | "stringHandler" | "value" | "initialContent" | "onStateChange" | "editable" | "autoFocus" | "onFocus" | "onBlur" | "onFirstRender" | "onDispatchTransaction" | "usesBuiltInExtensions" | "usesDefaultStyles" | "editorStyles" | "css" | "insertPosition" | "forceEnvironment" | "suppressHydrationWarning" | "fallbackContent">>) => string;

// Warning: (ae-forgotten-export) The symbol "InsertParams" needs to be exported by the entry point index.d.ts
//
// @public
export const replaceSelection: ({ view, content }: InsertParams) => Tags;

// @public
export const sequence: (...content: TaggedContentItem[]) => {
    nodes: TaggedProsemirrorNode<EditorSchema<string, string>>[];
    tags: Tags;
};

// @public (undocumented)
export const setupRemirrorEnvironment: () => void;

// @public (undocumented)
export const slice: (schema: EditorSchema<string, string>) => (...content: TaggedContentWithText[]) => Slice<EditorSchema<string, string>>;

// @public
export type TaggedContent = TaggedContentItem | Array<ProsemirrorNode | TaggedContentItem>;

// @public
export type TaggedContentItem = TaggedProsemirrorNode | TagTracker;

// @public
export type TaggedContentWithText = string | TaggedContent;

// @public
export interface TaggedProsemirrorNode<GSchema extends EditorSchema = EditorSchema> extends Node<GSchema> {
    // (undocumented)
    tags: Tags;
}

// @public
export interface Tags {
    // (undocumented)
    [name: string]: number;
}

// @public
export class TagTracker {
    // (undocumented)
    tags: Tags;
}

// @public
export const text: (value: string, schema: EditorSchema<string, string>) => TaggedContentItem;


// (No @packageDocumentation comment for this package)

```
